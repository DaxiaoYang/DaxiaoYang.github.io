<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://DaxiaoYang.github.io</id>
    <title>Gridea</title>
    <updated>2021-09-22T03:06:13.503Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://DaxiaoYang.github.io"/>
    <link rel="self" href="https://DaxiaoYang.github.io/atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://DaxiaoYang.github.io/images/avatar.png</logo>
    <icon>https://DaxiaoYang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[ThreadLocalæºç è§£æ]]></title>
        <id>https://DaxiaoYang.github.io/post/threadlocal-yuan-ma-jie-xi/</id>
        <link href="https://DaxiaoYang.github.io/post/threadlocal-yuan-ma-jie-xi/">
        </link>
        <updated>2021-09-22T03:04:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="çº¿ç¨‹å®‰å…¨">çº¿ç¨‹å®‰å…¨</h2>
<blockquote>
<p>çº¿ç¨‹å®‰å…¨å®šä¹‰ï¼š</p>
<p>class is thread-safe when it continues to behave correctly when accessed</p>
<p>from multiple threads</p>
<p>Correctness means that a class <em>conforms to its specifification</em>.</p>
</blockquote>
<p><strong>å®ç°çº¿ç¨‹å®‰å…¨çš„æ–¹æ³•</strong></p>
<ul>
<li>
<p>åŠ é”ï¼šä¿è¯ä¿®æ”¹æ•°æ®çš„æ“ä½œçš„åŸå­æ€§</p>
</li>
<li>
<p>CASï¼šä¹Ÿæ˜¯ä¿è¯ä¿®æ”¹æ•°æ®çš„æ“ä½œçš„åŸå­æ€§</p>
</li>
<li>
<p>ä½¿ç”¨ä¸å¯å˜å¯¹è±¡ï¼šä½¿å¾—å¯¹è±¡åœ¨åˆ›å»ºä¹‹åå°±ä¸å¯ä¿®æ”¹ï¼Œä¸å­˜åœ¨å¹¶å‘ä¿®æ”¹é—®é¢˜</p>
</li>
<li>
<p>Copy-On-Write</p>
</li>
<li>
<p>ä½¿ç”¨çº¿ç¨‹ç§æœ‰æ•°æ®ï¼šçº¿ç¨‹æ“ä½œçš„æ•°æ®åªæœ‰çº¿ç¨‹èƒ½è®¿é—®ï¼Œå…¶ä»–çº¿ç¨‹è®¿é—®ä¸åˆ°</p>
<p>è€ŒThreadLocalåˆ™æ˜¯JDKæä¾›çš„å¸®åŠ©æˆ‘ä»¬å­˜å–çº¿ç¨‹ç§æœ‰æ•°æ®çš„ç±»</p>
</li>
</ul>
<h2 id="threadlocalçš„ç”¨é€”">ThreadLocalçš„ç”¨é€”</h2>
<ul>
<li>
<p>å®ç°çº¿ç¨‹å®‰å…¨ï¼Œé¿å…æ•°æ®è¢«å¹¶å‘ä¿®æ”¹</p>
</li>
<li>
<p>ç¼“å­˜</p>
<p>å¦‚æœæŸä¸ªçº¿ç¨‹ä¸€ç›´å­˜æ´»ï¼ˆæ¯”å¦‚çº¿ç¨‹æ± ä¸­çš„æ ¸å¿ƒçº¿ç¨‹ï¼‰ï¼Œä¸”éœ€è¦é¢‘ç¹ç”¨åˆ°æŸä¸ªæ•°æ®ï¼Œåˆ™å¯ä»¥å°†æ•°æ®å­˜å‚¨åˆ°çº¿ç¨‹ç§æœ‰æ•°æ®ä¸­(JVMå†…å­˜æ¨¡å‹ä¸­çš„æ ˆ)</p>
</li>
<li>
<p>çº¿ç¨‹æ•°æ®é¿å…æ˜¾å¼ä¼ å‚</p>
</li>
<li>
<p>ä½œä¸ºå¯¹è±¡æ± ï¼šå¯¹è±¡ä½¿ç”¨å®Œä¹‹åæ¸…é™¤ä¿¡æ¯ æ”¾å›ï¼Œå†æ¬¡ä½¿ç”¨æ—¶å–å‡ºå³å¯</p>
</li>
</ul>
<p><strong>ä½¿ç”¨ç¤ºä¾‹</strong></p>
<pre><code class="language-java">import java.util.concurrent.atomic.AtomicLong;

/**
 * @ description:åˆ©ç”¨ThreadLocalç”Ÿæˆçº¿ç¨‹çš„ID
 * @ author: daxiao
 * @ date: 2021/9/16
 */
public class ThreadId {

  	// ç”Ÿæˆè¿›ç¨‹å†…å”¯ä¸€çš„çº¿ç¨‹ID
    private static final AtomicLong nextId = new AtomicLong(0);

    // ä½¿ç”¨é™æ€å·¥å‚æ–¹æ³•withInitial() ç”Ÿæˆä¸€ä¸ªé‡å†™äº†initialValueæ–¹æ³•çš„ThreadLocalçš„å­ç±»
    private static final ThreadLocal&lt;Long&gt; threadId = ThreadLocal.withInitial(nextId::getAndIncrement);

    // æ¯ä¸ªè°ƒç”¨è¯¥é™æ€æ–¹æ³•çš„çº¿ç¨‹éƒ½è·å–äº†å”¯ä¸€çš„ID ç”±CASä¿è¯IDç”Ÿæˆçš„åŸå­æ€§
    public static long get() {
        return threadId.get();
    }
}
</code></pre>
<h2 id="æºç ">æºç </h2>
<p><strong>ä½¿ç”¨æµç¨‹</strong></p>
<ol>
<li>
<p>ç»§æ‰¿<code>ThreadLocal</code>ç±»ï¼Œ åœ¨å­ç±»ä¸­é‡å†™ <code>initialValue()</code>æ–¹æ³•</p>
<p>ä¸º<code>get()</code>æ–¹æ³•è®¾ç½®åˆå§‹å€¼ï¼Œè·å–å­ç±»å¯¹è±¡</p>
</li>
<li>
<p>çº¿ç¨‹è°ƒç”¨è°ƒç”¨<code>threadLocal.get()</code>è·å–åˆå§‹å€¼</p>
</li>
<li>
<p><code>threadLocal.set(newValue)</code> è®¾ç½®æ–°å€¼</p>
</li>
<li>
<p>ä½¿ç”¨å®Œæ¯•å å¦‚æœæœ‰å¿…è¦åˆ™<code>threadLocal.remove()</code></p>
<p>çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ç§æœ‰æ•°æ®å¦‚æœä¸æƒ³è¢«å…¶ä»–çº¿ç¨‹çœ‹åˆ°ï¼Œç”¨å®Œä¹‹åéœ€è¦removeæ‰ï¼Œå› ä¸ºçº¿ç¨‹ä¼šè¢«è°ƒç”¨è€…å¤ç”¨</p>
</li>
</ol>
<h3 id="åˆå§‹åŒ–">åˆå§‹åŒ–</h3>
<pre><code class="language-java">// ThreadLocalå¯¹è±¡åªæ˜¯ä½œä¸ºä¸€ä¸ªtoken ä¸€ä¸ªmapä¸­çš„keyä½¿ç”¨ æ‰€ä»¥å­˜å‚¨ä¸åŒå¯¹è±¡çš„ThreadLocalè®¾ç½®ä¸ºé™æ€æˆå‘˜å˜é‡å³å¯
private static ThreadLocal&lt;Integer&gt; cache = ThreadLocal.withInitial(() -&gt; 0);

// withInitialæ˜¯ä¸€ä¸ªé™æ€å·¥å‚æ–¹æ³• å®é™…ä¸Šè¿”å›çš„æ˜¯ä¸€ä¸ªé‡å†™äº†initialValueæ–¹æ³•çš„å­ç±»
static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; {

  private final Supplier&lt;? extends T&gt; supplier;

  SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) {
    this.supplier = Objects.requireNonNull(supplier);
  }

  @Override
  protected T initialValue() {
    return supplier.get();
  }
}

</code></pre>
<p><strong>ThreadLocalMapä¸¤ä¸ªå…³é”®ç‚¹</strong></p>
<ul>
<li>
<p>è§£å†³å“ˆå¸Œå†²çªçš„æ–¹å¼ï¼šçº¿æ€§æ¢æµ‹</p>
</li>
<li>
<p>ä½¿ç”¨å¼±å¼•ç”¨ä½œä¸ºmapä¸­entryçš„Keyä»¥å®ç°åƒåœ¾å›æ”¶</p>
<p>staleçŠ¶æ€ï¼šéœ€è¦è¢«å›æ”¶çš„çŠ¶æ€ï¼Œå¦‚æœ<code>entry.get() == null</code> å³Entryä¸­çš„key ThreadLocalç±»å·²ç»è¢«åƒåœ¾å›æ”¶ï¼Œè¢«WeakRefenceæŒ‡å‘çš„å¯¹è±¡ï¼Œå¦‚æœåªæœ‰WeakReferenceæŒ‡å‘å®ƒï¼Œå°±ä¼šè¢«å›æ”¶ï¼Œåˆ™æ¸…ç†entryä¸­çš„valueå’Œentryè‡ªèº«ï¼Œå°†å¼•ç”¨ç½®ç©ºï¼Œè¿›è¡Œåƒåœ¾å›æ”¶</p>
</li>
</ul>
<h3 id="è·å–">è·å–</h3>
<pre><code class="language-java">Integer integer = cache.get();

/*
	å®é™…å­˜å‚¨æ•°æ®çš„æ˜¯Threadå¯¹è±¡ä¸­çš„ThreadLocal.ThreadLocalMap threadLocals
	ThreadLocalç±»åªæ˜¯ä½œä¸ºä¸€ä¸ªè·å–å€¼çš„ä¸€ä¸ªKey
*/
public T get() {
  // è·å–å½“å‰çº¿ç¨‹å¯¹è±¡
  Thread t = Thread.currentThread();
  // è·å–å®é™…å­˜å‚¨çº¿ç¨‹ç§æœ‰æ•°æ®çš„map t.threadLocals;
  ThreadLocalMap map = getMap(t);
  if (map != null) {
    // mapä¸­çš„keyä¸ºå½“å‰çš„ThreadLocalå¯¹è±¡ 
    ThreadLocalMap.Entry e = map.getEntry(this);
    if (e != null) {
      @SuppressWarnings(&quot;unchecked&quot;)
      T result = (T)e.value;
      return result;
    }
  }
  return setInitialValue();
}


private T setInitialValue() {
  // è·å–åˆå§‹åŒ– æœªé‡å†™åˆ™ä¸ºnull
  T value = initialValue();
  Thread t = Thread.currentThread();
  ThreadLocalMap map = getMap(t);
  if (map != null)
    map.set(this, value);
  else
    // å»¶è¿Ÿåˆå§‹åŒ– çº¿ç¨‹ä¸­çš„map
    createMap(t, value);
  return value;
}


void createMap(Thread t, T firstValue) {
  t.threadLocals = new ThreadLocalMap(this, firstValue);
}

ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
  // åˆ›å»ºåˆå§‹å®¹é‡ä¸º16çš„Entryæ•°ç»„ å®¹é‡ ä¿è¯ä¸º2çš„å€æ•° ç”¨äºå°†å–ä½™æ“ä½œè½¬åŒ–ä¸ºé€Ÿåº¦è¾ƒå¿«çš„bitä¸æ“ä½œ
  // å¦‚capacity=16 16 - 1 = 15 äºŒè¿›åˆ¶ä¸º 0b1111 ä»»ä½•å…¶ä»–æ•°è·Ÿ0b1111ç›¸ä¸ æ‰€å¾—ç»“æœå°±ä½äº[0-15]è¿™ä¸ªåŒºé—´ä¸­
  table = new Entry[INITIAL_CAPACITY];
  // å“ˆå¸Œå€¼çš„ç”Ÿæˆç”±ä¸€ä¸ªå…¨å±€çš„AtomicInteger é—´éš”ä¸€å®šçš„è·ç¦»ç»™å‡º
  int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
  table[i] = new Entry(firstKey, firstValue);
  size = 1;
  // loadfactoræ˜¯ 2/3 å¦‚æœæ˜¯16 åˆ™åœ¨sizeä¸º10æ—¶è¿›è¡Œrehash 
  setThreshold(INITIAL_CAPACITY);
}


// å®é™…æ‰§è¡Œçš„åœ¨å“ˆå¸Œè¡¨ä¸­çš„getæ–¹æ³•
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
  int i = key.threadLocalHashCode &amp; (table.length - 1);
  // æ ¹æ®å“ˆå¸Œå€¼ è·å–å¯¹åº”slotä¸­çš„entry å¦‚æœkeyç›¸åŒ å³threadLocalå¯¹è±¡ç›¸åŒ åˆ™ç›´æ¥è¿”å›
  // ç›´æ¥æ¯”è¾ƒå¼•ç”¨å€¼çš„æ–¹æ³•æœ€å¿« åœ¨HashMapç±»ä¸­ä¹Ÿæ˜¯æœ€å…ˆæ¯”è¾ƒå¼•ç”¨å€¼å†è°ƒç”¨object.equalsæ–¹æ³•
  Entry e = table[i];
  if (e != null &amp;&amp; e.get() == key)
    return e;
  else
    // å¦åˆ™è¿›è¡Œçº¿æ€§æ¢æµ‹
    return getEntryAfterMiss(key, i, e);
}


private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
  Entry[] tab = table;
  int len = tab.length;
  // é‡åˆ°ä¸ºnullçš„entryæˆ–è€…æ˜¯ç›¸åº”çš„å¯¹è±¡
  while (e != null) {
    ThreadLocal&lt;?&gt; k = e.get();
    if (k == key)
      return e;
    // é‡åˆ°entryä¸ä¸ºnull ä½†æ˜¯keyä¸ºnullçš„æƒ…å†µ keyä¸ºå¼±å¼•ç”¨ å½“åªæœ‰è¿™é‡Œçš„å¼±å¼•ç”¨æŒ‡å‘threadLocalå¯¹è±¡æ—¶ åœ¨åƒåœ¾å›æ”¶æ—¶ ä¸ç®¡å†…å­˜æ˜¯å¦å¤Ÿä¸å¤Ÿç”¨ å¯¹è±¡éƒ½ä¼šè¢«æ¸…ç†æ‰ 
    if (k == null)
      expungeStaleEntry(i);
    else
      //  nextIndexä¸­å°±æ˜¯è¿›è¡Œç¯å½¢çš„çº¿æ€§æ¢æµ‹ å°†æ•°ç»„åœ¨é€»è¾‘ä¸Šè§†ä¸ºä¸€ä¸ªç¯ ((i + 1 &lt; len) ? i + 1 : 0)
      i = nextIndex(i, len);
    e = tab[i];
  }
  return null;
}


/*
	æ¸…é™¤å½“å‰entry å¹¶ä¸”ä¸€ç›´nextIndexç›´åˆ°é‡åˆ°null 
	å¯¹æ‰€é‡åˆ°çš„entry å¦‚æœæ˜¯staleçŠ¶æ€: keyä¸ºnullçš„ ç›´æ¥æ¸…ç©ºå¼•ç”¨ä¿¡æ¯
	ä¸ä¸ºstaleçŠ¶æ€çš„è¿›è¡Œrehash
*/
private int expungeStaleEntry(int staleSlot) {
  Entry[] tab = table;
  int len = tab.length;
  // expunge entry at staleSlot
  tab[staleSlot].value = null;
  tab[staleSlot] = null;
  size--;
  // Rehash until we encounter null
  Entry e;
  int i;
  for (i = nextIndex(staleSlot, len);
       (e = tab[i]) != null;
       i = nextIndex(i, len)) {
    ThreadLocal&lt;?&gt; k = e.get();
    if (k == null) {
      e.value = null;
      tab[i] = null;
      size--;
    } else {
      int h = k.threadLocalHashCode &amp; (len - 1);
      if (h != i) {
        tab[i] = null;
        while (tab[h] != null)
          h = nextIndex(h, len);
        tab[h] = e;
      }
    }
  }
  return i;
}
</code></pre>
<h3 id="è®¾ç½®">è®¾ç½®</h3>
<pre><code class="language-java">// setå’Œremoveæ–¹æ³•åŒæ ·ä¹Ÿæ˜¯æ“ä½œThreadLocalMap
public void set(T value) {
  Thread t = Thread.currentThread();
  ThreadLocalMap map = getMap(t);
  if (map != null)
    map.set(this, value);
  else
    createMap(t, value);
}

private void set(ThreadLocal&lt;?&gt; key, Object value) {
  Entry[] tab = table;
  int len = tab.length;
  int i = key.threadLocalHashCode &amp; (len-1);

  for (Entry e = tab[i];
       e != null;
       e = tab[i = nextIndex(i, len)]) {
    ThreadLocal&lt;?&gt; k = e.get();

    if (k == key) {
      e.value = value;
      return;
    }
		// æ¸…ç†staleçŠ¶æ€çš„entry
    if (k == null) {
      replaceStaleEntry(key, value, i);
      return;
    }
  }
  tab[i] = new Entry(key, value);
  int sz = ++size;
  // è¿›è¡Œlog(len)æˆ–è€…log(size)æ¬¡æ¢æµ‹æœªå‘ç°éœ€è¦æ¸…ç†çš„slot ä¸”è¾¾åˆ°éœ€è¦rehashæ—¶ è¿›è¡Œrehash
  if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
    rehash();
}

private void rehash() {
  // å…ˆæ¸…ç†staleæ•°æ® å¦‚æœæœ‰å°±å¯ä»¥å‡å°‘size 
  expungeStaleEntries();
  // å¦‚æœsizeè¿˜æ˜¯å¤§äºæŒ‡å®šå€¼ å°±ç»§ç»­æ‰§è¡Œæ‰©å®¹
  if (size &gt;= threshold - threshold / 4)
    resize();
}
</code></pre>
<h3 id="æ¸…é™¤">æ¸…é™¤</h3>
<pre><code class="language-java">// removeä¹‹å å½“å‰çº¿ç¨‹å†è°ƒç”¨getæ–¹æ³• å°±ä¼šå†æ¬¡è§¦å‘initialValueçš„é€»è¾‘
public void remove() {
  ThreadLocalMap m = getMap(Thread.currentThread());
  if (m != null)
    m.remove(this);
}

private void remove(ThreadLocal&lt;?&gt; key) {
  Entry[] tab = table;
  int len = tab.length;
  int i = key.threadLocalHashCode &amp; (len-1);
  for (Entry e = tab[i];
       e != null;
       e = tab[i = nextIndex(i, len)]) {
    // æ‰¾åˆ°ç›¸åº”çš„entry
    if (e.get() == key) {
      // key = null è®¾ç½®ä¸ºstaleçŠ¶æ€
      e.clear();
      // æ¸…ç†è¯¥entry ä»¥åŠå‘åéå† æ¸…ç†stale entryå’Œrehash entry ç›´åˆ°é‡åˆ°null
      expungeStaleEntry(i);
      return;
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Guava EventBus]]></title>
        <id>https://DaxiaoYang.github.io/post/guava-eventbus/</id>
        <link href="https://DaxiaoYang.github.io/post/guava-eventbus/">
        </link>
        <updated>2021-09-11T14:26:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="è§‚å¯Ÿè€…æ¨¡å¼">è§‚å¯Ÿè€…æ¨¡å¼</h2>
<p>æ¦‚å¿µï¼š</p>
<blockquote>
<p>åœ¨å¯¹è±¡ä¹‹é—´å®šä¹‰ä¸€ä¸ªä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³»ï¼Œ</p>
<p>å½“ä¸€ä¸ªå¯¹è±¡ï¼ˆè¢«è§‚å¯Ÿè€…ï¼‰çš„çŠ¶æ€å˜åŒ–æ—¶ï¼Œæ‰€æœ‰ä¾èµ–çš„å¯¹è±¡ï¼ˆè§‚å¯Ÿè€…ï¼‰éƒ½ä¼šè‡ªåŠ¨æ”¶åˆ°é€šçŸ¥</p>
</blockquote>
<p>ä½¿ç”¨åœºæ™¯ï¼š</p>
<blockquote>
<p>å½“ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿæ—¶ï¼Œä¼šå½±å“åˆ°å¾ˆå¤šå…¶ä»–æ¨¡å—çš„çŠ¶æ€ï¼ˆè€ƒè™‘åˆ°æ¨¡å—å¯èƒ½ä¼šä¸æ–­å¢å¤šï¼‰</p>
</blockquote>
<p>è§‚å¯Ÿè€…æ¨¡å¼å’Œç”Ÿäº§-æ¶ˆè´¹æ¨¡å‹çš„åŒºåˆ«ï¼š</p>
<ul>
<li>ä¸€å¯¹å¤šå’Œå¤šå¯¹å¤š</li>
<li>æ¶ˆæ¯è¢«å¤šä¸ªå¯¹è±¡æ¶ˆè´¹å’Œæ¶ˆæ¯è¢«ä¸€ä¸ªå¯¹è±¡æ¶ˆè´¹</li>
</ul>
<p><strong>å®ç°æ–¹å¼</strong></p>
<ul>
<li>ä¼ ç»Ÿæ–¹å¼å®ç°è§‚å¯Ÿè€…æ¨¡å¼ï¼š
<ol>
<li>å®šä¹‰è§‚å¯Ÿè€…æ¥å£</li>
<li>åœ¨è¢«è§‚å¯Ÿè€…ä¸­å®šä¹‰è§‚å¯Ÿè€…æ¥å£çš„é›†åˆ</li>
<li>å½“äº‹ä»¶å‘ç”Ÿæ—¶ è¢«è§‚å¯Ÿè€…éå†é›†åˆ è¿›è¡Œé€šçŸ¥</li>
</ol>
</li>
</ul>
<p><strong>ç¼ºç‚¹</strong>ï¼šéœ€è¦åœ¨è¢«è§‚å¯Ÿè€…ä¸­æ³¨å†Œè§‚å¯Ÿè€…</p>
<p>ä¼˜åŒ–ï¼š</p>
<ul>
<li>é€šè¿‡ä¸€ä¸ªä¸­é—´æ˜ å°„è¡¨å®ç°</li>
</ul>
<h2 id="guava-eventbus">Guava EventBus</h2>
<p>å®ç°è¿›ç¨‹å†…éƒ¨çš„å‘å¸ƒè®¢é˜…æ¨¡å‹ é¿å…æ˜¾ç¤ºæ³¨å†Œè§‚å¯Ÿè€… è¿›ä¸€æ­¥è§£è€¦</p>
<h3 id="æµç¨‹å›¾">æµç¨‹å›¾</h3>
<pre><code class="language-mermaid">graph TD
0(è§‚å¯Ÿè€…æ‰€åœ¨çš„ç±»å°†è‡ªèº«çš„è§‚å¯Ÿè€… å³æ–¹æ³•æ³¨å†Œåˆ°EventBusä¸­) --&gt; 1[EventBusæ„é€ äº‹ä»¶åˆ°è§‚å¯Ÿè€…çš„æ˜ å°„ç»“æ„]
1 --&gt; 2[äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥EventBus EventBusé€šè¿‡æ˜ å°„ç»“æ„æ‰¾åˆ°æ‰€æœ‰å¯¹åº”çš„è§‚å¯Ÿè€… å¹¶æ‰§è¡Œ]
</code></pre>
<h3 id="ç±»å›¾"><strong>ç±»å›¾</strong></h3>
<pre><code class="language-mermaid">classDiagram
	EventBus --* SubscriberRegistry
	EventBus --* Dispatcher
	EventBus --* Executor
	AsyncEventBus --|&gt; EventBus
	LegacyAsyncDispatcher --|&gt; Dispatcher
	ImmediateDispatcher --|&gt; Dispatcher
	PerThreadQueuedDispatcher --|&gt; Dispatcher
	DirectExecutor ..|&gt; Executor
	ThreadPoolExecutor ..|&gt; Executor
	EventBus --&gt; Subsriber
	Dispatcher --&gt; Subsriber
	SynchronizedSubscriber --|&gt; Subsriber
	class EventBus {
		-Executor executor
		-SubscriberRegistry subscribers
		-Dispatcher dispatcher
		-SubscriberExceptionHandler exceptionHandler
		+register(object) void
		+post(object) void
	}
	
	class SubscriberRegistry {
		~register(object) void
	}
	
	class Dispatcher {
		~dispatch(event, subsribers) void
	}
	
	class LegacyAsyncDispatcher {
	
	}
	
	class ImmediateDispatcher
	
	class PerThreadQueuedDispatcher
	
	class Executor {
		+execute(command) void
	}
	
	class DirectExecutor
	
	class ThreadPoolExecutor
	
	class AsyncEventBus
	
	class Subsriber {
		-EventBus bus
		~Object target
		-Method method
		-Executor executor
		~dispatchEvent(event) void
	}
	
	class SynchronizedSubscriber
</code></pre>
<p><strong>EventBusä¸­æˆå‘˜å˜é‡å„è‡ªçš„ä½œç”¨</strong></p>
<ul>
<li><code>SubscriberRegistry</code> : æ ¸å¿ƒç»„ä»¶ ç»´æŠ¤äº†äº‹ä»¶åˆ°äº‹ä»¶çš„æ‰€æœ‰è®¢é˜…è€…æ–¹æ³•çš„Map</li>
<li><code>Executor</code> ï¼šç”¨äºå®šä¹‰å¦‚ä½•è°ƒç”¨è®¢é˜…è€…æ–¹æ³•</li>
<li><code>Dispatcher</code>ï¼š æ§åˆ¶äº‹ä»¶åˆ†å‘åˆ°è®¢é˜…è€…æ–¹æ³•çš„æ¬¡åº</li>
<li><code>SubscriberExceptionHandler</code> : æ‰§è¡Œè®¢é˜…è€…æ–¹æ³•å‡ºé”™æ—¶æ‰§è¡Œçš„é€»è¾‘</li>
</ul>
<h3 id="eventbuså¯¹è±¡åˆ›å»º"><strong>EventBuså¯¹è±¡åˆ›å»º</strong></h3>
<p>ä¸¤ç§ç±»å‹ï¼š</p>
<ul>
<li>
<p>åŒæ­¥</p>
<pre><code class="language-java">EventBus eventBus = new EventBus();
// ç­‰ä»·äº
EventBus eventBus = new EventBus(
        // é»˜è®¤æ ‡è¯†ç¬¦æ ‡è¯†ç¬¦ 
  			&quot;default&quot;,
  			// åœ¨å‘å¸ƒäº‹ä»¶çš„çº¿ç¨‹ä¸­è°ƒç”¨è§‚å¯Ÿè€…æ–¹æ³•
        MoreExecutors.directExecutor(),
  			// æ¯ä¸ªå‘å¸ƒäº‹ä»¶çš„çº¿ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„é˜Ÿåˆ— ä¾æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºäº‹ä»¶å’Œè§‚å¯Ÿè€… æ‰§è¡Œé€šçŸ¥é€»è¾‘
        Dispatcher.perThreadDispatchQueue(),
  			// é»˜è®¤çš„å¼‚å¸¸å¤„ç†ï¼šè®°å½•æ—¥å¿—
        LoggingHandler.INSTANCE);
</code></pre>
</li>
<li>
<p>å¼‚æ­¥</p>
<pre><code class="language-java">EventBus eventBus = new AsyncEventBus(new ThreadPoolExecutor());
// ç­‰ä»·äº
EventBus eventBus = new EventBus(
  &quot;default&quot;, 
  // åœ¨çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ä¸­è°ƒç”¨è§‚å¯Ÿè€…æ–¹æ³•
  new ThreadPoolExecutor(), 
  // æ‰€æœ‰å‘å¸ƒäº‹ä»¶çš„çº¿ç¨‹å…±äº«ä¸€ä¸ªé˜Ÿåˆ—
  Dispatcher.legacyAsync(), 
  LoggingHandler.INSTANCE);)
</code></pre>
</li>
</ul>
<h3 id="æ³¨å†Œè§‚å¯Ÿè€…"><strong>æ³¨å†Œè§‚å¯Ÿè€…</strong></h3>
<p><em>è®¢é˜…è€…æ˜¯ä¸€ä¸ªæ–¹æ³•è€Œéä¸€ä¸ªç±»</em></p>
<ol>
<li>
<p>å®šä¹‰ä¸€ä¸ª<code>public</code>æ–¹æ³•ï¼Œå•ä¸€å…¥å‚ï¼Œå‚æ•°ç±»å‹ä¸ºæƒ³è¦æ¥æ”¶çš„äº‹ä»¶ç±»å‹</p>
</li>
<li>
<p>æ–¹æ³•ä¸ŠåŠ ä¸Š<code>@Subscribe</code>æ³¨è§£ è§¦å‘æ–¹æ³•æ—¶é»˜è®¤æ˜¯åŒæ­¥çš„</p>
<p>ï¼ˆå¦‚æœå…è®¸å¤šä¸ªçº¿ç¨‹è®¿é—® å¦‚ï¼šæ— çŠ¶æ€æ–¹æ³• è¿˜å¯ä»¥åŠ ä¸Š<code>@AllowConcurrentEvents</code>æ³¨è§£ï¼‰</p>
</li>
<li>
<p>å°†æ–¹æ³•æ‰€åœ¨çš„ç±» æ³¨å†Œåˆ°EventBusä¸­ <code>register(Object)</code></p>
</li>
</ol>
<pre><code class="language-java">public class Observer extends BaseObserver {

  	// å®šä¹‰äº‹ä»¶çš„è§‚å¯Ÿè€… äº‹ä»¶ç±»å‹å³ä¸ºæ‰€å®šä¹‰å‚æ•°çš„ç±»å‹
    @Subscribe
    @AllowConcurrentEvents
    public void onEvent(Integer event) {
        System.out.println(&quot;handle integer event:&quot; + event);
    }
    
}
// å°†æ–¹æ³•æ‰€åœ¨çš„ç±» æ³¨å†Œåˆ°EventBus
eventBus.register(new Observer());

// å®é™…è°ƒç”¨æ³¨å†Œè¡¨ 
void register(Object listener) {
  	// è·å–æ˜ å°„ï¼šäº‹ä»¶ -&gt; äº‹ä»¶å¯¹åº”çš„æ‰€æœ‰è®¢é˜…è€…ï¼ˆMethodå¯¹è±¡ï¼‰ MultiMapä¸­ä¸€ä¸ªKeyå¯ä»¥å¯¹åº”å¤šä¸ªValue
    Multimap&lt;Class&lt;?&gt;, Subscriber&gt; listenerMethods = findAllSubscribers(listener);
		// å°†æ˜ å°„å°†å…¥åˆ°å…¨å±€çš„Mapä¸­
    for (Entry&lt;Class&lt;?&gt;, Collection&lt;Subscriber&gt;&gt; entry : listenerMethods.asMap().entrySet()) {
      Class&lt;?&gt; eventType = entry.getKey();
      Collection&lt;Subscriber&gt; eventMethodsInListener = entry.getValue();
      CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);
      if (eventSubscribers == null) {
        CopyOnWriteArraySet&lt;Subscriber&gt; newSet = new CopyOnWriteArraySet&lt;&gt;();
        eventSubscribers =
            MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);
      }
      eventSubscribers.addAll(eventMethodsInListener);
    }
  }

// æ„å»ºæ˜ å°„ï¼šäº‹ä»¶ -&gt; äº‹ä»¶å¯¹åº”çš„æ‰€æœ‰è®¢é˜…è€…ï¼ˆMethodå¯¹è±¡ï¼‰
private Multimap&lt;Class&lt;?&gt;, Subscriber&gt; findAllSubscribers(Object listener) {
    Multimap&lt;Class&lt;?&gt;, Subscriber&gt; methodsInListener = HashMultimap.create();
    Class&lt;?&gt; clazz = listener.getClass();
  	// æ³¨è§£æ‰«æ
    for (Method method : getAnnotatedMethods(clazz)) {
      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
      Class&lt;?&gt; eventType = parameterTypes[0];
      // æƒ³æƒ³ä¸ºä»€ä¹ˆéœ€è¦æŠŠEventBuså¯¹è±¡å’Œè®¢é˜…è€…æ‰€åœ¨çš„ç±»å¯¹è±¡ä¹Ÿå°è£…è¿›å»ï¼Ÿ
      // Subsriberè´Ÿè´£è°ƒç”¨æ–¹æ³• é»˜è®¤æƒ…å†µä¸‹å¯ä»¥ä¿è¯åœ¨EventBusä¸­è°ƒç”¨è¯¥æ–¹æ³•çš„çº¿ç¨‹å®‰å…¨
      methodsInListener.put(eventType, Subscriber.create(bus, listener, method));
    }
    return methodsInListener;
  }

// getAnnotatedMethods(clazz)å®é™…æ‰§è¡Œé€»è¾‘
private static ImmutableList&lt;Method&gt; getAnnotatedMethodsNotCached(Class&lt;?&gt; clazz) {
  	// è·å–è¯¥ç±»æ‰€æœ‰çš„çˆ¶ç±»ä¸æ¥å£ç±»åŠå…¶æœ¬èº«çš„Classå¯¹è±¡
    Set&lt;? extends Class&lt;?&gt;&gt; supertypes = TypeToken.of(clazz).getTypes().rawTypes();
  	// ç”¨äºè¿‡æ»¤é‡å¤çš„è§‚å¯Ÿè€…ï¼šæ–¹æ³•ç­¾åç›¸åŒçš„
    Map&lt;MethodIdentifier, Method&gt; identifiers = Maps.newHashMap();
    for (Class&lt;?&gt; supertype : supertypes) {
      for (Method method : supertype.getDeclaredMethods()) {
        // åˆ¤æ–­è¯¥æ–¹æ³•æ˜¯å¦å­˜åœ¨@Subsribeæ³¨è§£
        if (method.isAnnotationPresent(Subscribe.class) &amp;&amp; !method.isSynthetic()) {
          Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
          // ...çœç•¥å‚æ•°æ ¡éªŒï¼š1.æ ¡éªŒå‚æ•°ä¸ªæ•°æ˜¯å¦ä¸ºä¸€ä¸ª 2.æ˜¯å¦ä¸ºå¯¹è±¡ç±»å‹
          MethodIdentifier ident = new MethodIdentifier(method);
          if (!identifiers.containsKey(ident)) {
            identifiers.put(ident, method);
          }
        }
      }
    }
  	// è¿”å›æ‰€æœ‰è§‚å¯Ÿè€…
    return ImmutableList.copyOf(identifiers.values());
  }

// å¾ˆé‡è¦çš„ä¸€ä¸ªå°è£…ç±»ï¼šSubsriberçš„åˆ›å»º
static Subscriber create(EventBus bus, Object listener, Method method) {
  // è¯¥æ–¹æ³•ä¸Šæ²¡æœ‰@AllowConcurrentEventsæ³¨è§£åˆ™é»˜è®¤åˆ›å»ºåŒæ­¥çš„Subsriber åŒºåˆ«åé¢å‘å¸ƒäº‹ä»¶ è°ƒç”¨æ–¹æ³•æ—¶ä¼šè¯´  
  return isDeclaredThreadSafe(method)
        ? new Subscriber(bus, listener, method)
        : new SynchronizedSubscriber(bus, listener, method);
  }

private static boolean isDeclaredThreadSafe(Method method) {
    return method.getAnnotation(AllowConcurrentEvents.class) != null;
  }
</code></pre>
<h3 id="å‘å¸ƒäº‹ä»¶-é€šçŸ¥è®¢é˜…è€…"><strong>å‘å¸ƒäº‹ä»¶ é€šçŸ¥è®¢é˜…è€…</strong></h3>
<ol>
<li>å°†äº‹ä»¶å¯¹è±¡æ”¾å…¥EventBusçš„<code>post</code>æ–¹æ³•ä¸­ï¼ŒEventBusä¼šå°†è¯¥äº‹ä»¶é€šçŸ¥åˆ°æ‰€æœ‰æ³¨å†Œçš„è§‚å¯Ÿè€…ä¸­</li>
<li>äº‹ä»¶å¿…é¡»æ˜¯ä¸€ä¸ªå¯¹è±¡ ä¼šé€šçŸ¥æ‰€æœ‰è¯¥å¯¹è±¡åŠå…¶èƒ½æ¥å—è¯¥å¯¹è±¡çš„çˆ¶ç±»/æ¥å£</li>
<li>å¦‚æœæ²¡æœ‰è§‚å¯Ÿè€…æ³¨å†Œæ¥æ”¶è¿™ä¸ªäº‹ä»¶ï¼Œåˆ™ä¼šå°†è¿™ä¸ªäº‹ä»¶åŒ…è£…æˆä¸€ä¸ªDeadEvent é€šçŸ¥DeadEventçš„è§‚å¯Ÿè€…</li>
</ol>
<pre><code class="language-java">// å‘å¸ƒè€…å‘å¸ƒäº‹ä»¶
for (int i = 0; i &lt; 3; i++) {
  eventBus.post(i);
}

public void post(Object event) {
  	// è·å–è¯¥ç±»åŠå…¶æ‰€æœ‰çˆ¶ç±»çš„Classå¯¹è±¡å¯¹åº”çš„è®¢é˜…è€…
    Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);
  	// å¦‚æœå­˜åœ¨è®¢é˜…è€… åˆ™é€šè¿‡åˆ†å‘å™¨é€šçŸ¥å¯¹åº”çš„è®¢é˜…è€…äº‹ä»¶å‘ç”Ÿ
    if (eventSubscribers.hasNext()) {
      // å‘å¸ƒäº‹ä»¶åˆ°æ‰€æœ‰çš„è®¢é˜…è€…ä¸Š
      dispatcher.dispatch(event, eventSubscribers);
    } else if (!(event instanceof DeadEvent)) {
      // æ‰¾ä¸åˆ°å¯¹åº”çš„è®¢é˜…è€…ä¸”è‡ªèº«ä¸æ˜¯DeadEventç±»å‹ï¼ˆç¨‹åºç¼–å†™é”™è¯¯ï¼‰ 
      // å°è£…æˆDeadEventå¯¹è±¡å†æ¬¡å‘å¸ƒ æ‰€ä»¥å¯ä»¥æ³¨å†Œä¸€ä¸ªè§‚å¯ŸDeadEventçš„è®¢é˜…è€… ç”¨äºå®šä½é—®é¢˜
      post(new DeadEvent(this, event));
    }
}


Iterator&lt;Subscriber&gt; getSubscribers(Object event) {
  	// è·å–è¯¥ç±»åŠå…¶æ‰€æœ‰çˆ¶ç±»çš„Classå¯¹è±¡
    ImmutableSet&lt;Class&lt;?&gt;&gt; eventTypes = flattenHierarchy(event.getClass());
    List&lt;Iterator&lt;Subscriber&gt;&gt; subscriberIterators =
        Lists.newArrayListWithCapacity(eventTypes.size());
    for (Class&lt;?&gt; eventType : eventTypes) {
      CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);
      if (eventSubscribers != null) {
        // eager no-copy snapshot
        subscriberIterators.add(eventSubscribers.iterator());
      }
    }
    return Iterators.concat(subscriberIterators.iterator());
  }



// åŒæ­¥EventBusä¸­é»˜è®¤ä½¿ç”¨çš„åˆ†å‘æ–¹å¼
private static final class PerThreadQueuedDispatcher extends Dispatcher {

    /** çº¿ç¨‹ç§æœ‰çš„é˜Ÿåˆ—ï¼šå­˜å‚¨äº‹ä»¶å¯¹è±¡å’Œå¯¹åº”çš„è®¢é˜…è€…çš„å°è£…ç±»å¯¹è±¡ */
    private final ThreadLocal&lt;Queue&lt;Event&gt;&gt; queueï¼›

    /** çº¿ç¨‹ç§æœ‰çš„æ ‡å¿— */
    private final ThreadLocal&lt;Boolean&gt; dispatchingï¼›

    @Override
    void dispatch(Object event, Iterator&lt;Subscriber&gt; subscribers) {
      // è·å–å‘å¸ƒè€…çº¿ç¨‹ç§æœ‰çš„é˜Ÿåˆ—
      Queue&lt;Event&gt; queueForThread = queue.get();
      queueForThread.offer(new Event(event, subscribers));
      if (!dispatching.get()) {
        dispatching.set(true);
        try {
          Event nextEvent;
          while ((nextEvent = queueForThread.poll()) != null) {
            while (nextEvent.subscribers.hasNext()) {
              // è°ƒç”¨Subsriberçš„dispatchEvent
              nextEvent.subscribers.next().dispatchEvent(nextEvent.event);
            }
          }
        } finally {
          dispatching.remove();
          queue.remove();
        }
      }
    }
  }

// å¼‚æ­¥EventBusä¸­é»˜è®¤ä½¿ç”¨çš„åˆ†å‘æ–¹å¼
private static final class LegacyAsyncDispatcher extends Dispatcher {

    /** Global event queue. */
    private final ConcurrentLinkedQueue&lt;EventWithSubscriber&gt; queue =
        Queues.newConcurrentLinkedQueue();

    @Override
    void dispatch(Object event, Iterator&lt;Subscriber&gt; subscribers) {
      // åŠ å…¥å…¨å±€é˜Ÿåˆ—
      while (subscribers.hasNext()) {
        queue.add(new EventWithSubscriber(event, subscribers.next()));
      }
			// å°†å…¨å±€é˜Ÿåˆ—ä¸­çš„methodéƒ½è§¦å‘å®Œ
      EventWithSubscriber e;
      while ((e = queue.poll()) != null) {
        e.subscriber.dispatchEvent(e.event);
      }
    }
 }

class Subscriber {

  /** The event bus this subscriber belongs to. */
  @Weak private EventBus bus;

  /** The object with the subscriber method. */
  @VisibleForTesting final Object target;

  /** Subscriber method. */
  private final Method method;

  /** Executor to use for dispatching events to this subscriber. */
  private final Executor executor;
  
  final void dispatchEvent(final Object event) {
    // æ¨¡æ¿æ–¹æ³• å°†æ‰§è¡Œè®¢é˜…è€…æ–¹æ³•çš„é€»è¾‘å°è£…æˆä¸€ä¸ªRunnableåŒ¿åå­ç±»å¯¹è±¡ è®©Executoræ‰§è¡Œ
    executor.execute(
      new Runnable() {
        @Override
        public void run() {
          try {
       			// å…·ä½“æ‰§è¡Œ
            invokeSubscriberMethod(event);
          } catch (InvocationTargetException e) {
            // æ‰§è¡Œä¸­å‡ºç°å¼‚å¸¸ åˆ™å°è£…å¼‚å¸¸ä¸Šä¸‹æ–‡ äº¤ç»™SubscriberExceptionHandlerå¤„ç†
            bus.handleSubscriberException(e.getCause(), context(event));
          }
        }
      });
  }
  
  
  void invokeSubscriberMethod(Object event) throws InvocationTargetException {
    try {
      // åå°„è°ƒç”¨
      method.invoke(target, checkNotNull(event));
    } catch (IllegalArgumentException e) {
      throw new Error(&quot;Method rejected target/argument: &quot; + event, e);
    } catch (IllegalAccessException e) {
      throw new Error(&quot;Method became inaccessible: &quot; + event, e);
    } catch (InvocationTargetException e) {
      if (e.getCause() instanceof Error) {
        throw (Error) e.getCause();
      }
      throw e;
    }
  }
  
  static final class SynchronizedSubscriber extends Subscriber {
		
    // å­ç±»ä¼šç»™è¯¥æ–¹æ³•åŠ é” ä¿è¯ä¸€æ¬¡åªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œmethod.invoke
    @Override
    void invokeSubscriberMethod(Object event) throws InvocationTargetException {
      synchronized (this) {
        super.invokeSubscriberMethod(event);
      }
    }
  }
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcatçº¿ç¨‹æ± ]]></title>
        <id>https://DaxiaoYang.github.io/post/tomcat-xian-cheng-chi/</id>
        <link href="https://DaxiaoYang.github.io/post/tomcat-xian-cheng-chi/">
        </link>
        <updated>2021-09-11T14:22:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="tomcat">Tomcat</h2>
<blockquote>
<p>Tomcatæ˜¯ä¸€ä¸ªWebå®¹å™¨</p>
</blockquote>
<p>ä¸€ä¸ªWebå®¹å™¨çš„ä¸»è¦åŠŸèƒ½ï¼š</p>
<ul>
<li>å¤„ç†Socketè¿æ¥ è´Ÿè´£ç½‘ç»œå­—èŠ‚æµå’Œ<code>Request</code> <code>Response</code>å¯¹è±¡ä¹‹é—´çš„è½¬åŒ–</li>
<li>ç®¡ç†Servletçš„ç”Ÿå‘½å‘¨æœŸï¼Œé€šè¿‡Servletå¤„ç†<code>Request</code>è¯·æ±‚</li>
</ul>
<p>Tomcatçš„ä¸¤å¤§ç»„æˆéƒ¨åˆ†ï¼š</p>
<ul>
<li>è¿æ¥å™¨ <em>Connector</em> ï¼ˆä½œä¸ºHTTPæœåŠ¡å™¨ï¼‰</li>
<li>å®¹å™¨ <em>Container</em> ï¼ˆä½œä¸ºServletå®¹å™¨ï¼‰</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/ee/d6/ee880033c5ae38125fa91fb3c4f8cad6.jpg" alt="" loading="lazy"></figure>
<h2 id="å¯¹è±¡æ± ">å¯¹è±¡æ± </h2>
<p>åº”ç”¨åœºæ™¯ï¼›</p>
<p>æŸç§å¯¹è±¡æ•°é‡å¤š è‡ªèº«å ç”¨ç©ºé—´å¤š åˆ›å»ºå’Œåˆå§‹åŒ–è€—æ—¶ ä½†å­˜åœ¨æ—¶é—´çŸ­</p>
<p>é‚£ä¹ˆè¿™äº›å¯¹è±¡çš„é¢‘ç¹çš„åˆ›å»º åˆå§‹åŒ– GCéƒ½ä¼šæ¶ˆè€—å¤§é‡çš„CPUå’Œå†…å­˜èµ„æº</p>
<p><strong>å®ç°æ–¹æ³•</strong>ï¼š</p>
<p>æŠŠä¸€ä¸ªå¯¹è±¡ç”¨å®Œä¹‹åå°†å®ƒä¿å­˜èµ·æ¥ï¼Œéœ€è¦å†ç”¨æ—¶å†æ‹¿å‡ºæ¥ï¼ˆæ¸…ç©ºä¹‹å‰çš„ä¿¡æ¯ å¦‚æœæœ‰å¿…è¦ï¼‰</p>
<p>è¿›è¡Œé‡å¤ä½¿ç”¨ï¼ˆç©ºé—´æ¢æ—¶é—´ï¼‰</p>
<h2 id="jdkçº¿ç¨‹æ± ">JDKçº¿ç¨‹æ± </h2>
<p><code>java.util.concurrent.ThreadPoolExecutor</code></p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre>
<p><strong>æ„é€ å‚æ•°</strong></p>
<ul>
<li>
<p>æ ¸å¿ƒçº¿ç¨‹æ•°ï¼š</p>
</li>
<li>
<p>æœ€å¤§çº¿ç¨‹æ•° = æ ¸å¿ƒçº¿ç¨‹æ•° + ä¸´æ—¶çº¿ç¨‹æ•°</p>
<blockquote>
<p>æ ¸å¿ƒçº¿ç¨‹ï¼šåˆ›å»ºåä¸€ç›´å­˜æ´»çš„çº¿ç¨‹æ•°ï¼ˆé™¤é<code>allowCoreThreadTimeOut</code>å‚æ•°ä¸ºtrueï¼‰</p>
<p>ä¸´æ—¶çº¿ç¨‹ï¼šå½“ä¸€å®šçš„æ—¶é—´å†…ä»å·¥ä½œé˜Ÿåˆ—ä¸­è·å–ä¸åˆ°Runnableå¯¹è±¡ï¼Œè¯¥çº¿ç¨‹é”€æ¯</p>
<p>æ ¸å¿ƒçº¿ç¨‹å’Œä¸´æ—¶çº¿ç¨‹çš„åŒºåˆ«æ–¹å¼ï¼šä»å·¥ä½œé˜Ÿåˆ—ä¸­æ‹‰å–Runnableå¯¹è±¡çš„æ–¹å¼ä¸åŒï¼ˆå—å½“å‰çº¿ç¨‹æ•°ä¸æ ¸å¿ƒçº¿ç¨‹æ•°çš„å½±å“ï¼‰</p>
<pre><code class="language-java">// å°è¯•ä»å·¥ä½œäº†é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ 
// åœ¨Workerç±»ä¸­çš„runWorkeræ–¹æ³•ä¸­çš„å¾ªç¯ä¸­è¢«è°ƒç”¨ 
// å½“è¯¥æ–¹æ³•è¿”å›nullæ—¶ä¼šé€€å‡ºå¾ªç¯ 
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
        for (;;) {
            int c = ctl.get();
            int wc = workerCountOf(c);
            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }
            try {
              	// æ ¸å¿ƒçº¿ç¨‹å’Œä¸´æ—¶çº¿ç¨‹çš„åŒºåˆ«å°±åœ¨è¿™é‡Œ
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
</code></pre>
</blockquote>
</li>
<li>
<p>ä¸´æ—¶çº¿ç¨‹æœ€å¤§ç©ºé—²æ—¶é—´</p>
<p>ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯ç”¨äºè®¾å®šä¸´æ—¶çº¿ç¨‹ä»å·¥ä½œé˜Ÿåˆ—ä¸­å°è¯•è·å–Runnableå¯¹è±¡çš„æ—¶é—´</p>
<p><code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code></p>
</li>
<li>
<p>å·¥ä½œé˜Ÿåˆ—ï¼šé˜»å¡é˜Ÿåˆ—</p>
</li>
<li>
<p>çº¿ç¨‹å·¥å‚</p>
</li>
<li>
<p>æ‹’ç»ç­–ç•¥ï¼šå›è°ƒå‡½æ•°</p>
</li>
</ul>
<p><strong>æ‰§è¡Œæµç¨‹</strong></p>
<ol>
<li>
<p>å‰ corePoolSize ä¸ªä»»åŠ¡æ—¶ï¼Œæ¥ä¸€ä¸ªä»»åŠ¡å°±åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ã€‚</p>
</li>
<li>
<p>åé¢å†æ¥ä»»åŠ¡ï¼Œå°±æŠŠä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—é‡Œè®©æ‰€æœ‰çš„çº¿ç¨‹å»æŠ¢ï¼Œå¦‚æœ<strong>åŠ å…¥é˜Ÿåˆ—å¤±è´¥</strong>å°±åˆ›å»ºä¸´æ—¶çº¿ç¨‹ã€‚</p>
<blockquote>
<p>è¿™é‡ŒåŠ å…¥é˜Ÿåˆ—å¤±è´¥çš„å®šä¹‰ä¸ºé˜Ÿåˆ—å·²æ»¡</p>
</blockquote>
</li>
<li>
<p>å¦‚æœå½“å‰çº¿ç¨‹æ•°è¾¾åˆ° maximumPoolSizeï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥ã€‚</p>
</li>
</ol>
<pre><code class="language-java">// å‘çº¿ç¨‹æ± ä¸­æäº¤ä¸€ä¸ªä»»åŠ¡
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
  			// è·å–çº¿ç¨‹æ§åˆ¶çŠ¶æ€ï¼šint(32) = 3(çŠ¶æ€ä½) + 29(çº¿ç¨‹æ•°)
        int c = ctl.get();
  			// å½“å‰çº¿ç¨‹æ•°å°äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼š
        if (workerCountOf(c) &lt; corePoolSize) {
          	// åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹å¹¶åœ¨ä¸€ä¸ªå¾ªç¯ä¸æ–­å°è¯•è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ
          	// ä»»åŠ¡æ¥æºï¼š1.åˆ›å»ºçº¿ç¨‹æ—¶èµ‹äºˆçš„ 2.ä»å·¥ä½œé˜Ÿåˆ—ä¸­æ‹‰å–çš„ 
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
  			// å½“å‰çº¿ç¨‹æ•°ä»¥è¾¾åˆ°æ ¸å¿ƒçº¿ç¨‹æ•°ï¼šå°†ä»»åŠ¡æ”¾åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
  			// æ”¾å…¥å·¥ä½œé˜Ÿåˆ—å¤±è´¥ï¼ˆofferæ–¹æ³•è¿”å›falseï¼‰: å°è¯•åˆ›å»ºä¸€ä¸ªä¸´æ—¶çº¿ç¨‹æ‰§è¡Œå®ƒ
        else if (!addWorker(command, false))
          	// å½“å‰çº¿ç¨‹æ•°å·²è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼šæ‰§è¡Œæ‹’ç»ç­–ç•¥
            reject(command);
}

// çº¿ç¨‹æ§åˆ¶çŠ¶æ€ åˆå§‹intå€¼ä¸º111åŠ ä¸Š29ä¸ª0
AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

int CAPACITY = (1 &lt;&lt; 29) - 1 // ä¹Ÿå°±æ˜¯000åŠ ä¸Š29ä¸ª1
  
// è·å–çº¿ç¨‹æ± çŠ¶æ€
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }

// è·å–çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°é‡
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
</code></pre>
<pre><code class="language-java">// åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ 
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            for (;;) {
                int wc = workerCountOf(c);
              	// coreä¸ºtrueåˆ™ç”¨æ ¸å¿ƒçº¿ç¨‹æ•°ä½œä¸ºä¸Šé™åˆ¤æ–­ ä¸ºfalseåˆ™ç”¨æœ€å¤§çº¿ç¨‹æ•°ä½œä¸ºä¸Šé™
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
            }
        }
        boolean workerStarted = false;
        boolean workerAdded = false;
  			// Workeræ„é€ æ–¹æ³•é‡Œé¢åˆ›å»ºäº†çº¿ç¨‹ å¹¶å°†Workerä½œä¸ºRunnableä¼ ç»™è¯¥çº¿ç¨‹
  			// class Worker extends AbstractQueuedSynchronizer implements Runnable
        Worker w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
      		// åŠ é”ä¿éšœçº¿ç¨‹HashSet&lt;Worker&gt; workersçš„çº¿ç¨‹å®‰å…¨
          final ReentrantLock mainLock = this.mainLock;
          mainLock.lock();
          try {
            workers.add(w);
            workerAdded = true;
          }
        } finally {
          mainLock.unlock();
        }
        if (workerAdded) {
          // t.start()ä¼šè°ƒç”¨Threadçš„Runnableå¯¹è±¡çš„runæ–¹æ³• å³Workerå¯¹è±¡çš„Runæ–¹æ³•
          t.start();
          workerStarted = true;
        }
      }
      return workerStarted;
}

// Workeræ„é€ æ–¹æ³•
Worker(Runnable firstTask) {
  setState(-1); // inhibit interrupts until runWorker
  this.firstTask = firstTask;
  // å°†Workerä½œä¸ºRunnableä¼ ç»™è¯¥çº¿ç¨‹
  this.thread = getThreadFactory().newThread(this);
}

// Workerå¯¹è±¡çš„Runæ–¹æ³•ä¼šè°ƒç”¨è¯¥æ–¹æ³•
final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
  			// ä»»åŠ¡æ¥æº1ï¼šåˆ›å»ºWorkerå¯¹è±¡æ—¶èµ‹äºˆ
        Runnable task = w.firstTask;
        w.firstTask = null;
  			boolean completedAbruptly = true;
        try {
          	// å¾ªç¯ä¸­ä¸æ–­å°è¯•è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ
          	// ä»»åŠ¡æ¥æº2ï¼šä»getTask()ä¸­è·å–
            while (task != null || (task = getTask()) != null) {
                try {
                  	task.run();
                } finally {
                    task = null;
                }
            }
            completedAbruptly = false;
        } finally {
          	// é€€å‡ºå¾ªç¯åï¼ˆå³getTask()è¿”å›nullï¼‰æ¸…é™¤Workerå¯¹è±¡
            processWorkerExit(w, completedAbruptly);
        }
}
</code></pre>
<h2 id="tomcatçº¿ç¨‹æ± ">Tomcatçº¿ç¨‹æ± </h2>
<blockquote>
<p>åœ¨JDKçº¿ç¨‹æ± çš„åŸºç¡€ä¸Šè¿›è¡Œäº†ä¸€å®šçš„æ‰©å±•</p>
</blockquote>
<p><strong>Tomcatçº¿ç¨‹æ± è·Ÿæˆ‘ä»¬ä¸šåŠ¡å¼€å‘çš„å…³ç³»</strong></p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/30/cf/309cae2e132210489d327cf55b284dcf.jpg" alt="" loading="lazy"></figure>
<ol>
<li>Endpoint æ¥æ”¶åˆ° Socket è¿æ¥åï¼Œç”Ÿæˆä¸€ä¸ª SocketProcessor ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± å»å¤„ç†</li>
<li>SocketProcessor çš„ run æ–¹æ³•ä¼šè°ƒç”¨ Processor ç»„ä»¶å»è§£æåº”ç”¨å±‚åè®®</li>
<li>Processor é€šè¿‡è§£æç”Ÿæˆ Request å¯¹è±¡åï¼Œä¼šè°ƒç”¨ Adapter çš„ Service æ–¹æ³•</li>
<li>Adapterä¸­ä¼šè°ƒç”¨å®¹å™¨ æœ€ç»ˆä¼šè°ƒç”¨Servletçš„Serviceæ–¹æ³•ï¼ˆSpringMVCå®ç°äº†Servletæ¥å£ï¼‰</li>
</ol>
<pre><code class="language-java">// é»˜è®¤å‚æ•°
// å®šåˆ¶çš„ä»»åŠ¡é˜Ÿåˆ— TaskQueue extends LinkedBlockingQueue&lt;Runnable&gt;
taskqueue = new TaskQueue(Integer.MAX_VALUE);

// å®šåˆ¶çš„çº¿ç¨‹å·¥å‚ TaskThreadFactory implements ThreadFactory
TaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());

// å®šåˆ¶çš„çº¿ç¨‹æ±  ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor
executor = new ThreadPoolExecutor(25, 200, 60000, TimeUnit.MILLISECONDS,taskqueue, tf);
</code></pre>
<p>Tomcatçº¿ç¨‹æ± çš„æ‰§è¡Œæµç¨‹ï¼š</p>
<ol>
<li>
<p>å‰ corePoolSize ä¸ªä»»åŠ¡æ—¶ï¼Œæ¥ä¸€ä¸ªä»»åŠ¡å°±åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ã€‚</p>
</li>
<li>
<p>å†æ¥ä»»åŠ¡çš„è¯ï¼Œå°±æŠŠä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—é‡Œè®©æ‰€æœ‰çš„çº¿ç¨‹å»æŠ¢ï¼Œå¦‚æœ<strong>åŠ å…¥é˜Ÿåˆ—å¤±è´¥</strong>å°±åˆ›å»ºä¸´æ—¶çº¿ç¨‹ã€‚</p>
<blockquote>
<p>è¿™é‡ŒåŠ å…¥é˜Ÿåˆ—å¤±è´¥çš„å®šä¹‰: å³<code>workQueue.offer()</code>æ–¹æ³•è¿”å›falseçš„é€»è¾‘</p>
<ul>
<li>é˜Ÿåˆ—å·²æ»¡ <code>size == capacity</code></li>
<li>å·²æäº¤ä½†æœªå®Œæˆçš„ä»»åŠ¡æ•° &gt; å½“å‰çº¿ç¨‹æ•°ï¼ˆä¹Ÿå°±æ˜¯è¯´æœ‰ä»»åŠ¡æ²¡æœ‰åˆ†é…åˆ°çº¿ç¨‹è¿›è¡Œæ‰§è¡Œ éœ€è¦çº¿ç¨‹ï¼‰</li>
</ul>
</blockquote>
</li>
<li>
<p>å¦‚æœæ€»çº¿ç¨‹æ•°è¾¾åˆ° maximumPoolSizeï¼Œ</p>
<p><strong>åˆ™ä¸€æ®µæ—¶é—´å ç»§ç»­å°è¯•æŠŠä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­å»</strong></p>
<p><strong>å¦‚æœä¸€æ®µæ—¶é—´å ä»»åŠ¡é˜Ÿåˆ—è¿˜æ˜¯æ»¡çš„ï¼Œæ’å…¥å¤±è´¥ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥</strong></p>
</li>
</ol>
<pre><code class="language-java">public class ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor {
  
  // å·²ç»æäº¤ä½†æ˜¯è¿˜æ²¡æœ‰æ‰§è¡Œçš„ä»»åŠ¡æ•°é‡
  private final AtomicInteger submittedCount = new AtomicInteger(0);
  
  public void execute(Runnable command, long timeout, TimeUnit unit) {
      submittedCount.incrementAndGet();
      try {
          //è°ƒç”¨JavaåŸç”Ÿçº¿ç¨‹æ± çš„executeå»æ‰§è¡Œä»»åŠ¡
          super.execute(command);
      } catch (RejectedExecutionException rx) {
         // å·¥ä½œé˜Ÿåˆ—å·²æ»¡ä¸”æ€»çº¿ç¨‹æ•°è¾¾åˆ°maximumPoolSize é»˜è®¤çš„æ‹’ç»ç­–ç•¥è¢«æ‰§è¡Œ(å³æŠ›å‡ºå¼‚å¸¸)
          if (super.getQueue() instanceof TaskQueue) {
              final TaskQueue queue = (TaskQueue)super.getQueue();
              try {
                  // ç­‰å¾…ä¸€æ®µæ—¶é—´å å†æŠŠä»»åŠ¡æ”¾åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­å»
                	// å› ä¸ºå¯èƒ½åœ¨ç­‰å¾…çš„è¿™æ®µæ—¶é—´ä¸­ ä»»åŠ¡é˜Ÿåˆ—æœ‰ä½ç½®ç©ºäº†å‡ºæ¥
                  if (!queue.force(command, timeout, unit)) {
                      submittedCount.decrementAndGet();
                      // ä¸€æ®µæ—¶é—´å é˜Ÿåˆ—ä»ç„¶æ˜¯æ»¡çš„ï¼Œæ’å…¥å¤±è´¥ï¼Œåˆ™æ‰§è¡Œæ‹’ç»ç­–ç•¥ã€‚
                      throw new RejectedExecutionException(&quot;...&quot;);
                  }
              } 
          }
      }
}
</code></pre>
<pre><code class="language-java">public class TaskQueue extends LinkedBlockingQueue&lt;Runnable&gt; {
	
  private transient volatile ThreadPoolExecutor parent;
  
  
   @Override
  // çº¿ç¨‹æ± è°ƒç”¨offeræ–¹æ³•æ—¶ï¼Œå½“å‰çº¿ç¨‹æ•°è‚¯å®šå·²ç»å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°äº†
  // æ¥ä¸‹æ¥åˆ¤æ–­ï¼šæ˜¯å°†ä»»åŠ¡æ”¾åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­è¿˜æ˜¯åˆ›å»ºæ–°çš„çº¿ç¨‹æ‰§è¡Œè¯¥ä»»åŠ¡
  public boolean offer(Runnable o) {

      //å¦‚æœçº¿ç¨‹æ•°å·²ç»åˆ°äº†æœ€å¤§å€¼ï¼Œä¸èƒ½åˆ›å»ºæ–°çº¿ç¨‹äº†ï¼Œåªèƒ½æŠŠä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ã€‚
      if (parent.getPoolSize() == parent.getMaximumPoolSize()) 
          return super.offer(o);
          
      //æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¡¨æ˜å½“å‰çº¿ç¨‹æ•°å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå¹¶ä¸”å°äºæœ€å¤§çº¿ç¨‹æ•°ã€‚
      //è¡¨æ˜æ˜¯å¯ä»¥åˆ›å»ºæ–°çº¿ç¨‹çš„ï¼Œé‚£åˆ°åº•è¦ä¸è¦åˆ›å»ºå‘¢ï¼Ÿåˆ†ä¸¤ç§æƒ…å†µï¼š
      
      //1. å¦‚æœå·²æäº¤çš„ä»»åŠ¡æ•°å°äºå½“å‰çº¿ç¨‹æ•°ï¼Œè¡¨ç¤ºè¿˜æœ‰ç©ºé—²çº¿ç¨‹ï¼Œæ— éœ€åˆ›å»ºæ–°çº¿ç¨‹
      if (parent.getSubmittedCount()&lt;=(parent.getPoolSize())) 
          return super.offer(o);
          
      //2. å¦‚æœå·²æäº¤çš„ä»»åŠ¡æ•°å¤§äºå½“å‰çº¿ç¨‹æ•°ï¼Œçº¿ç¨‹ä¸å¤Ÿç”¨äº†ï¼Œè¿”å›falseå»åˆ›å»ºæ–°çº¿ç¨‹
      if (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) 
          return false;
          
      //é»˜è®¤æƒ…å†µä¸‹æ€»æ˜¯æŠŠä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—
      return super.offer(o);
  }
  
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://DaxiaoYang.github.io/post/hello-gridea/</id>
        <link href="https://DaxiaoYang.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>